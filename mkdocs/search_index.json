{
    "docs": [
        {
            "location": "/", 
            "text": "Citrix Virtual Channel SDK for Citrix Receiver for Android\n\n\nThe Citrix Virtual Channel Software Development Kit (SDK) provides support for writing server-side applications and client-side drivers for additional virtual channels using the ICA protocol. The server-side virtual channel applications are on XenApp or XenDesktop servers. This version of the SDK provides support for writing new virtual channels for Receiver for Android. If you want to write virtual drivers for other client platforms, contact Citrix.\n\n\nThe Virtual Channel SDK provides:\n\n\n\n\n\n\nThe Citrix Android Virtual Driver AIDL Interfaces: \nIVCService.aidl\n and \nIVCCallback.aidl\n, used with the virtual channel functions in the Citrix Server API SDK (WFAPI SDK) to create new virtual channels.\n\n\n\n\n\n\nA helper class \nMarshall.java\n designed to make writing your own virtual channels easier.\n\n\n\n\n\n\nWorking source code for three virtual channel sample programs that demonstrate programming techniques.\n\n\n\n\n\n\nThe Virtual Channel SDK requires the WFAPI SDK to write the server side of the virtual channel. You can find this resource from the Citrix website or by contacting us.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#citrix-virtual-channel-sdk-for-citrix-receiver-for-android", 
            "text": "The Citrix Virtual Channel Software Development Kit (SDK) provides support for writing server-side applications and client-side drivers for additional virtual channels using the ICA protocol. The server-side virtual channel applications are on XenApp or XenDesktop servers. This version of the SDK provides support for writing new virtual channels for Receiver for Android. If you want to write virtual drivers for other client platforms, contact Citrix.  The Virtual Channel SDK provides:    The Citrix Android Virtual Driver AIDL Interfaces:  IVCService.aidl  and  IVCCallback.aidl , used with the virtual channel functions in the Citrix Server API SDK (WFAPI SDK) to create new virtual channels.    A helper class  Marshall.java  designed to make writing your own virtual channels easier.    Working source code for three virtual channel sample programs that demonstrate programming techniques.    The Virtual Channel SDK requires the WFAPI SDK to write the server side of the virtual channel. You can find this resource from the Citrix website or by contacting us.", 
            "title": "Citrix Virtual Channel SDK for Citrix Receiver for Android"
        }, 
        {
            "location": "/system-requirements/", 
            "text": "System Requirements\n\n\nThe Virtual Channel SDK is based on the Android service binding mechanism. The custom virtual driver must be implemented as a service. The Virtual Channel SDK and Citrix Receiver for Android are delivered in two packages. As required, the Client OS or\nsecurity software must enable Citrix Receiver for Android to do a secondary launch of the custom virtual driver. For most of Android devices, secondary launch is enabled by default. Yet some devices from specific manufactures have disabled this function by default. For more information, see \nKnown Limitations\n.\n\n\nExecution Environment Requirements\n\n\nServer requirement\n\n\nThe Android Virtual Channel SDK is supported on Citrix XenApp 6.5 and later, and on Citrix XenDesktop 7.6 and later.\n\n\nAndroid client requirement\n\n\nCitrix Receiver for Android 3.11 and later\n\n\nArchitecture\n\n\nA Citrix Independent Computing Architecture (ICA) virtual channel is a bidirectional, error-free connection for the exchange of generalized packet data between a server running Citrix XenApp or XenDesktop, and a client device. You can use virtual channels to add functionality to clients. Uses for virtual channels include:\n\n\n\n\n\n\nSupport for administrative functions\n\n\n\n\n\n\nNew data streams (audio and video)\n\n\n\n\n\n\nNew devices, such as scanners, card readers, and joysticks\n\n\n\n\n\n\nVirtual Channel Overview\n\n\nAn ICA virtual channel is a bidirectional, error-free connection for the exchange of generalized packet data between a client and a server running XenApp or XenDesktop. Each implementation of an ICA virtual channel consists of two components:\n\n\nServer-side portion on the computer running XenApp or XenDesktop\n\n\nThe virtual channel on the server side is a normal Win32 process.It can be an application or a Windows NT service.\n\n\nClient-side portion on the Android device\n\n\nThe client-side custom virtual channel driver executes in the context of the client. You must write your virtual driver. For the Android client, the custom virtual driver must be implemented as a service, communicating with Citrix Receiver for Android through the AIDL interfaces provided in this version of the Virtual Channel SDK. If you want to create several virtual channels, you must implement one virtual driver for each channel.\n\n\nThis figure illustrates the virtual channel client-server connection:\n\n\n\n\nCitrix Receiver for Android is responsible for demultiplexing the virtual channel data from the ICA data stream and routing it to the correct processing module (in this case, the virtual driver). It is also responsible for gathering and sending virtual channel data to the server through the ICA connection. Citrix Receiver for Android does not know any data package detail for each virtual channel and it only transfers all available data between the server and the client virtual driver.\n\n\nThe following is an overview of the client-server data exchange using a virtual channel:\n\n\n\n\n\n\nThe client connects to the server running XenApp or XenDesktop. The client passes information about the virtual channels that it supports to the server.\n\n\n\n\n\n\nThe server-side application starts, obtains a handle to the virtual channel, and optionally queries for additional information about the channel.\n\n\n\n\n\n\nBoth the client-side virtual driver and server-side application can send data initiatively:\n\n\n\n\n\n\nIf the server application has data to send to the client, the data is sent to the client immediately. When the client     receives the data, Citrix Receiver for Android demultiplexes the virtual channel data from the ICA stream and passes it     immediately to the client virtual driver.\n\n\n\n\n\n\nIf the client virtual driver has data to send to the server, the data is also sent immediately.\n\n\n\n\n\n\n\n\n\n\nWhen the ICA session disconnects or something unexpected occurs, such as runtime exceptions or errors, the virtual channel closes and the client virtual driver (service) disconnects from Citrix Receiver for Android.\n\n\n\n\n\n\nICA and Virtual Channel Data Packets\n\n\nVirtual channel data packets are encapsulated in the ICA stream between the client and the server. Because ICA is a presentation-level protocol and runs over several different transports, the virtual channel API enables you to write your protocols without worrying about the underlying transport. The data packet is preserved.\n\n\nFor example, if 100 bytes are sent to the server, the same 100 bytes are received by the server when the virtual channel is demultiplexed from the ICA data stream. The compiled code runs independently of the currently configured transport protocol.\n\n\nThe ICA engine provides the following services to the virtual channel:\n\n\nPacket encapsulation\n\n\nICA virtual channels are packet-based, meaning that if one side performs a write with a certain amount of data, the other side receives the entire block of data when it performs a read. This contrasts with TCP, for example, which is stream-based and requires a higher-level protocol to parse out packet boundaries. Stated another way, virtual channel packets are contained within the ICA stream, which is managed separately by the system software.\n\n\nError correction\n\n\nICA provides its own reliability mechanisms even when the underlying transport is unreliable. This guarantees that connections are error-free and that data is received in the order in which it is sent.\n\n\nReceiver and Virtual Driver Interaction\n\n\nIn Citrix Receiver for Android, the custom virtual driver is implemented as a service and it must be installed on the Android device before an ICA session is launched. Once a user launches an ICA session, Citrix Receiver for Android binds this service by using the Android API bindService with the \nBIND\\_AUTO\\_CREATE\n flag set. That means that if the service has not been started before the ICA session launches, Citrix Receiver for Android starts this service automatically and the lifecycle of the service is contingent on the ICA session. Only when binding successfully, is the virtual channel created. If the virtual driver service is not bound successfully, the ICA session can still be launched but no virtual channel is created for the virtual driver. So the virtual driver you write must never block or perform time-consuming tasks in the onCreate(), onBind() methods which might increase the risk of binding failure.\n\n\nFor more information about Android service binding and lifecycle, see the \nAndroid developer documentation\n.\n\n\nThe following process occurs when a user starts the client:\n\n\n\n\n\n\nAt client load time, Citrix Receiver for Android finds all the eligible services installed on the device, based on Intent action (see Programming Guide for more information).\n\n\n\n\n\n\nCitrix Receiver for Android binds all eligible services. If the service is not started, Citrix Receiver for Android starts it. After binding succeeds, Citrix Receiver for Android and the virtual driver service communicate through the Android AIDL interface.\n\n\n\n\n\n\nFor each service, Citrix Receiver for Android calls the canLoad method to verify whether the virtual channel must be created for this virtual driver. If canLoad returns false, Receiver cannot create a virtual channel for it.\n\n\n\n\n\n\nIf canLoad returns true, Citrix Receiver for Android calls getVCName, getMaxVersionNumber, getMinVersionNumber, and getDisplayName to get essential information of this virtual channel. Then it calls initializeDriver to provide the opportunity for the service to do initialization work.\n\n\n\n\n\n\nIf initialization completes successfully, Citrix Receiver for Android creates the virtual channel and calls driverStart.\n\n\n\n\n\n\nWhen virtual channel data arrives from the server, Citrix Receiver for Android calls the ICADataArrival method for that virtual driver.\n\n\n\n\n\n\nTo send data, the virtual driver uses sendData callback to send data to the server.\n\n\n\n\n\n\nIf a user disconnects the ICA sessionor something unexpected occurs, such as RuntimeException or an errorduring data transfer, the virtual channel closes and the binding between Citrix Receiver forAndroid and the virtual driver disconnects. Citrix Receiver forAndroid calls driverShutdown to inform the virtual driver. After thevirtual channel closes, data cannot be sent to the server.\n\n\n\n\n\n\nConsidering the particulars of the Android platform, the virtual driverservice can be collected by the OS when resources are not sufficientafter the ICA session launches. Citrix Receiver for Android has a basic mechanism to try to restart the service and restore the data stream by repeating the steps above and passing blocked data. With this mechanism,in some cases, a user does not need to relaunch the ICA session when the virtual driver is killed. When Citrix Receiver for Android is not aware of the contents of the custom virtual channel package, this mechanism is not reliable. Although the probability is very low, if the virtual driver service is killed after the ICA session launches and thismechanism doesn\u2019t work, the user has to relaunch the ICA session to make the virtual driver work again.\n\n\nVirtual Channel Packets\n\n\nICA does not define the contents of a virtual channel packet. The contents are specific to the particular virtual channel and are not interpreted or managed by the ICA data stream manager. You must develop your own protocol for the virtual channel data.\n\n\nA virtual channel packet can be any length up to the maximum size supported by the ICA connection. This size is independent of size restrictions on the lower-layer transport. These restrictions affect the server-side WFVirtualChannelRead and WFVirtualChannelWrite functions and sendData callback on the client side. The maximum packet size is 5000 bytes (4996 data bytes plus 4 bytes of packet overhead generated by the ICA datastream manager).\n\n\nBecause Citrix Receiver for Android is not aware of the details of the virtual channel package, it passes all available data in the ICA stream to virtual driver by calling icaDataArrival. Data is passed to the virtual driver as a byte array. If the virtual channel package is large enough, the whole package might not arrive at the same time. That means that the implementation of the client virtual driver needs to be able to handle a partial package. See the Ping, Over, and Mix sample code, which provides examples for handling partial packages.\n\n\nIf the server-application sends several packages continuously, more than one package might arrive in the same byte array. The implementation of this method needs to also be able to handle more than one package in the array. See the Over and Mix sample code, which provides examples for handling more than one package in one byte array. For Ping sample, server-application sends\ndata synchronously, the server waits for the client to reply before sending the next packet. Ping sample does not need to handle this scenario.", 
            "title": "System Requirements"
        }, 
        {
            "location": "/system-requirements/#system-requirements", 
            "text": "The Virtual Channel SDK is based on the Android service binding mechanism. The custom virtual driver must be implemented as a service. The Virtual Channel SDK and Citrix Receiver for Android are delivered in two packages. As required, the Client OS or\nsecurity software must enable Citrix Receiver for Android to do a secondary launch of the custom virtual driver. For most of Android devices, secondary launch is enabled by default. Yet some devices from specific manufactures have disabled this function by default. For more information, see  Known Limitations .", 
            "title": "System Requirements"
        }, 
        {
            "location": "/system-requirements/#execution-environment-requirements", 
            "text": "", 
            "title": "Execution Environment Requirements"
        }, 
        {
            "location": "/system-requirements/#server-requirement", 
            "text": "The Android Virtual Channel SDK is supported on Citrix XenApp 6.5 and later, and on Citrix XenDesktop 7.6 and later.", 
            "title": "Server requirement"
        }, 
        {
            "location": "/system-requirements/#android-client-requirement", 
            "text": "Citrix Receiver for Android 3.11 and later", 
            "title": "Android client requirement"
        }, 
        {
            "location": "/system-requirements/#architecture", 
            "text": "A Citrix Independent Computing Architecture (ICA) virtual channel is a bidirectional, error-free connection for the exchange of generalized packet data between a server running Citrix XenApp or XenDesktop, and a client device. You can use virtual channels to add functionality to clients. Uses for virtual channels include:    Support for administrative functions    New data streams (audio and video)    New devices, such as scanners, card readers, and joysticks", 
            "title": "Architecture"
        }, 
        {
            "location": "/system-requirements/#virtual-channel-overview", 
            "text": "An ICA virtual channel is a bidirectional, error-free connection for the exchange of generalized packet data between a client and a server running XenApp or XenDesktop. Each implementation of an ICA virtual channel consists of two components:  Server-side portion on the computer running XenApp or XenDesktop  The virtual channel on the server side is a normal Win32 process.It can be an application or a Windows NT service.  Client-side portion on the Android device  The client-side custom virtual channel driver executes in the context of the client. You must write your virtual driver. For the Android client, the custom virtual driver must be implemented as a service, communicating with Citrix Receiver for Android through the AIDL interfaces provided in this version of the Virtual Channel SDK. If you want to create several virtual channels, you must implement one virtual driver for each channel.  This figure illustrates the virtual channel client-server connection:   Citrix Receiver for Android is responsible for demultiplexing the virtual channel data from the ICA data stream and routing it to the correct processing module (in this case, the virtual driver). It is also responsible for gathering and sending virtual channel data to the server through the ICA connection. Citrix Receiver for Android does not know any data package detail for each virtual channel and it only transfers all available data between the server and the client virtual driver.  The following is an overview of the client-server data exchange using a virtual channel:    The client connects to the server running XenApp or XenDesktop. The client passes information about the virtual channels that it supports to the server.    The server-side application starts, obtains a handle to the virtual channel, and optionally queries for additional information about the channel.    Both the client-side virtual driver and server-side application can send data initiatively:    If the server application has data to send to the client, the data is sent to the client immediately. When the client     receives the data, Citrix Receiver for Android demultiplexes the virtual channel data from the ICA stream and passes it     immediately to the client virtual driver.    If the client virtual driver has data to send to the server, the data is also sent immediately.      When the ICA session disconnects or something unexpected occurs, such as runtime exceptions or errors, the virtual channel closes and the client virtual driver (service) disconnects from Citrix Receiver for Android.", 
            "title": "Virtual Channel Overview"
        }, 
        {
            "location": "/system-requirements/#ica-and-virtual-channel-data-packets", 
            "text": "Virtual channel data packets are encapsulated in the ICA stream between the client and the server. Because ICA is a presentation-level protocol and runs over several different transports, the virtual channel API enables you to write your protocols without worrying about the underlying transport. The data packet is preserved.  For example, if 100 bytes are sent to the server, the same 100 bytes are received by the server when the virtual channel is demultiplexed from the ICA data stream. The compiled code runs independently of the currently configured transport protocol.  The ICA engine provides the following services to the virtual channel:  Packet encapsulation  ICA virtual channels are packet-based, meaning that if one side performs a write with a certain amount of data, the other side receives the entire block of data when it performs a read. This contrasts with TCP, for example, which is stream-based and requires a higher-level protocol to parse out packet boundaries. Stated another way, virtual channel packets are contained within the ICA stream, which is managed separately by the system software.  Error correction  ICA provides its own reliability mechanisms even when the underlying transport is unreliable. This guarantees that connections are error-free and that data is received in the order in which it is sent.", 
            "title": "ICA and Virtual Channel Data Packets"
        }, 
        {
            "location": "/system-requirements/#receiver-and-virtual-driver-interaction", 
            "text": "In Citrix Receiver for Android, the custom virtual driver is implemented as a service and it must be installed on the Android device before an ICA session is launched. Once a user launches an ICA session, Citrix Receiver for Android binds this service by using the Android API bindService with the  BIND\\_AUTO\\_CREATE  flag set. That means that if the service has not been started before the ICA session launches, Citrix Receiver for Android starts this service automatically and the lifecycle of the service is contingent on the ICA session. Only when binding successfully, is the virtual channel created. If the virtual driver service is not bound successfully, the ICA session can still be launched but no virtual channel is created for the virtual driver. So the virtual driver you write must never block or perform time-consuming tasks in the onCreate(), onBind() methods which might increase the risk of binding failure.  For more information about Android service binding and lifecycle, see the  Android developer documentation .  The following process occurs when a user starts the client:    At client load time, Citrix Receiver for Android finds all the eligible services installed on the device, based on Intent action (see Programming Guide for more information).    Citrix Receiver for Android binds all eligible services. If the service is not started, Citrix Receiver for Android starts it. After binding succeeds, Citrix Receiver for Android and the virtual driver service communicate through the Android AIDL interface.    For each service, Citrix Receiver for Android calls the canLoad method to verify whether the virtual channel must be created for this virtual driver. If canLoad returns false, Receiver cannot create a virtual channel for it.    If canLoad returns true, Citrix Receiver for Android calls getVCName, getMaxVersionNumber, getMinVersionNumber, and getDisplayName to get essential information of this virtual channel. Then it calls initializeDriver to provide the opportunity for the service to do initialization work.    If initialization completes successfully, Citrix Receiver for Android creates the virtual channel and calls driverStart.    When virtual channel data arrives from the server, Citrix Receiver for Android calls the ICADataArrival method for that virtual driver.    To send data, the virtual driver uses sendData callback to send data to the server.    If a user disconnects the ICA sessionor something unexpected occurs, such as RuntimeException or an errorduring data transfer, the virtual channel closes and the binding between Citrix Receiver forAndroid and the virtual driver disconnects. Citrix Receiver forAndroid calls driverShutdown to inform the virtual driver. After thevirtual channel closes, data cannot be sent to the server.    Considering the particulars of the Android platform, the virtual driverservice can be collected by the OS when resources are not sufficientafter the ICA session launches. Citrix Receiver for Android has a basic mechanism to try to restart the service and restore the data stream by repeating the steps above and passing blocked data. With this mechanism,in some cases, a user does not need to relaunch the ICA session when the virtual driver is killed. When Citrix Receiver for Android is not aware of the contents of the custom virtual channel package, this mechanism is not reliable. Although the probability is very low, if the virtual driver service is killed after the ICA session launches and thismechanism doesn\u2019t work, the user has to relaunch the ICA session to make the virtual driver work again.", 
            "title": "Receiver and Virtual Driver Interaction"
        }, 
        {
            "location": "/system-requirements/#virtual-channel-packets", 
            "text": "ICA does not define the contents of a virtual channel packet. The contents are specific to the particular virtual channel and are not interpreted or managed by the ICA data stream manager. You must develop your own protocol for the virtual channel data.  A virtual channel packet can be any length up to the maximum size supported by the ICA connection. This size is independent of size restrictions on the lower-layer transport. These restrictions affect the server-side WFVirtualChannelRead and WFVirtualChannelWrite functions and sendData callback on the client side. The maximum packet size is 5000 bytes (4996 data bytes plus 4 bytes of packet overhead generated by the ICA datastream manager).  Because Citrix Receiver for Android is not aware of the details of the virtual channel package, it passes all available data in the ICA stream to virtual driver by calling icaDataArrival. Data is passed to the virtual driver as a byte array. If the virtual channel package is large enough, the whole package might not arrive at the same time. That means that the implementation of the client virtual driver needs to be able to handle a partial package. See the Ping, Over, and Mix sample code, which provides examples for handling partial packages.  If the server-application sends several packages continuously, more than one package might arrive in the same byte array. The implementation of this method needs to also be able to handle more than one package in the array. See the Over and Mix sample code, which provides examples for handling more than one package in one byte array. For Ping sample, server-application sends\ndata synchronously, the server waits for the client to reply before sending the next packet. Ping sample does not need to handle this scenario.", 
            "title": "Virtual Channel Packets"
        }, 
        {
            "location": "/using-example-programs/", 
            "text": "Using Example Programs\n\n\nThe example programs included with the Virtual Channel SDK are buildable, working virtual channels. Use these examples to:\n\n\n\n\n\n\nVerify that your environment is suitable by building a known working example program.\n\n\n\n\n\n\nProvide working examples of code that can be modified to suit your requirements.\n\n\n\n\n\n\nExplore the features and functionality provided in the Virtual Channel SDK.\n\n\n\n\n\n\nEach of these example programs comprises a client virtual driver and a server application. The server-side application is run from the command line within an ICA session. A single virtual channel comprises an application pair.\n\n\nThe example programs included with the Virtual Channel SDK are:\n\n\nPing\n: Records the round-trip delay time for a test packet sent over a virtual channel.\n\n\nMix\n: Demonstrates a mechanism to call functions (for example, to get the time of day) on a remote client.\n\n\nOver\n: Simple asynchronous application that demonstrates how to code an application where the server must receive a response from the client asynchronously, and where the type of packet being sent to the client is different from the type received.\n\n\nPing\n\n\nPing is a simple program that records the round-trip delay time for a test packet sent over a virtual channel. The server sends a packet to the client and the client responds with a packet containing the time it received the original packet from the server. This sequence is repeated a specified number of times, and then the program displays the round-trip time for each ping and the average round-trip delay time.\n\n\nFor this example, there is no significant difference between a BEGIN packet and an END packet. The two types of packets are provided as an example for writing your own virtual channel protocols.\n\n\nThis program demonstrates:\n\n\n\n\n\n\nHow to write a manifest file so that Citrix Receiver for Android can detect and bind the service.\n\n\n\n\n\n\nHow to send information to a server-application (in this case, the number of times to send packets to the client).\n\n\n\n\n\n\nHow to transfer data synchronously. The sequence of events is: \n{SrvWrite, ClntRead, ClntWrite, SrvRead} {SrvWrite, ClntRead} {...}\n. The server waits for the client to reply before sending the next packet.\n\n\n\n\n\n\nPacket Format\n\n\nThe following packet is exchanged between the client and the server.\n\n\nByte 0-1 uSign; // Signature\nByte 2-3 uType; // Type, BEGIN or END, from server\nByte 4-5 uLen; // Packet length from server\nByte 6-7 uCounter; // Sequencer\nByte 8-11 ulServerMS; // Server millisecond clock\nByte 12-15 ulClientMS; // Client millisecond clock\n\n\n\n\n\nMix\n\n\nMix demonstrates a mechanism that you can use to call functions on a\nremote client (for example to get the time of day). This program\ndemonstrates an extensible scheme for making function calls from the\nserver to the client that allows the server to specify when it expects a\nresponse from the client and when it does not. This method can increase\nperformance, because the server does not have to constantly wait for a\nreply from the client.\n\n\nThe server calls a series of simple functions:\n\n\n\n\n\n\nAddNo\n: Add two numbers and return the sum as the return value.\n\n\n\n\n\n\nDispStr\n: Write a string to the log file. There is no return value (write-only function).\n\n\n\n\n\n\nGettime\n: Read the client time and return it as the return value.\n\n\n\n\n\n\nThe actual implementation of these functions is on the client side. The server conditionally waits for the response from the client, depending on the function being executed. For example, the server waits for the result of the \nAddNo\n or \nGettime\n function, but not the write-only function \nDispStr\n, which returns no result.\n\n\nPacket Format\n\n\nByte 0-1 uType // Packet type\nByte 2-3 uFunc; // Index of Function\nByte 4-7 uLen; // Length of data\nByte 8-9 fRetReq; // True if return value required\nByte 10-13 dwRetVal; // Return Value from client\nByte 14-15 dwLen1; // length of data for \\#1 LpVoid\nByte 16-17 dwLen2; // length of data for \\#2 LpVoid\n\n\n\n\n\nThe data consists of the structure above followed by the arguments to the function being called. uLen is the total length of the data being sent, including the arguments. DwLen1 is the length of the data pointed to by a pointer argument.\n\n\nSequence of Events\n\n\nThe Mix program demonstrates the following sequence of events. See the graphic below.\n\n\nThis figure illustrates the sequence of events that occur when you use the Mix program, starting at the top.\n\n\n\n\nOver\n\n\nOver is a simple asynchronous application. It demonstrates how to code an application in which the server must receive a response from the client asynchronously, and the type of packet being sent to the client is different from the type received.\n\n\nWhen the Over program begins, it:\n\n\n\n\n\n\nSpawns a thread that waits for a response from the client.\n\n\n\n\n\n\nBegins sending data packets with sequence numbers to the client.\n\n\n\n\n\n\n(After sending the last packet of data) sends a packet with a sequence number of \nNO\\_MORE\\_DATA\n, and then closes the connection.\n\n\n\n\n\n\nThe client receives packets and inspects the sequence number. For every sequence number divisible by 10, the client increases the sequence number by 7 and sends a response to the server. These numbers are chosen arbitrarily to demonstrate that the client can asynchronously send data to the server at any time.\n\n\nThe packet type used to send data from the server to the client is different from the packet type used to receive data from the client.\n\n\nPacket Format - From Server to Client\n\n\nByte 0-1 uSign; // Signature\nByte 2-3 uType; // Type, BEGIN or END, from server\nByte 4-5 uLen; // Packet length from server\nByte 6-7 uCounter; // Sequencer\nByte 8-11 ulServerMS; // Server millisecond clock\n\n\n\n\n\nPacket Format - From Client to Server\n\n\nByte 0-1 uType; // Type OVERFLOW\\_JUMP from client\nByte 2-3 uLen; // Packet length from client\nByte 4-5 uCounter; // seqUencer\n\n\n\n\n\nSequence of Events\n\n\nThis figure illustrates the sequence of events that occur when you use the Over program, starting at the top.\n\n\n![](./over-sequence-of-events.png =625x)\n\n\nBuilding Examples\n\n\nBuilding a server-side example using Nmake\n\n\nExamples of the latest server-side executables have been provided for testing. You can download the latest Windows Virtual Channel SDK in order to develop the server-side component.\n\n\nBuilding a client-side example\n\n\nCitrix provides APKs for the three sample virtual drivers. You can build the APKs yourself. The packages for sample virtual drivers are built using Gradle.\n\n\nEnvironment information of sample code:\n\n\n\n\n\n\nGradle version: 2.10.\n\n\n\n\n\n\nGradle build tool version: 21.1.2.\n\n\n\n\n\n\nAndroid SDK version: 21.\n\n\n\n\n\n\nJDK version: Oracle JDK 7.\n\n\n\n\n\n\nBuilding steps:\n\n\n\n\n\n\nSets \n\\$JAVA\\_HOME, \\$ANDROID\\_HOME, \\$GRADLE\\_HOME\n to the directory you installed. Adds \n\\$JAVA\\_HOME and \\$GRADLE\\_HOME/bin\n to \n\\$PATH\n.\n\n\n\n\n\n\nOpens a Command line in the root directory of a sample package.\n\n\n\n\n\n\nRuns \u201cgradle assemble\u201d in Commandline.\n\n\n\n\n\n\nWhen a build completes, you can find the APKs under \n./app/build/outputs/apk\n.\n\n\n\n\n\n\nThe APKs must be installed to your device before an ICA session launches.\n\n\nRunning an Example Virtual Channel\n\n\nExamples of the latest server-side executables have been provided for testing.\n\n\n\n\n\n\nOn a client installed with the client-side example, connect to a server running XenApp or XenDesktop with the associated server-side example.\n\n\n\n\n\n\nWithin the ICA session, run the server-side executable.\n\n\n\n\n\n\nThe server-side example queries the client-side virtual driver, and then displays the driver information. Use the \n-d\n parameter to display detailed information. For Ping only: \nCTXPING\n sends \nPingCount\n separate pings. \nPingCount\n has a default value of three, but can be set in the \n\\[Ping\\]\n section of the \nModule.ini\n file. Each ping consists of a \nBEGIN\n packet and an \nEND\n packet.", 
            "title": "Using Example Programs"
        }, 
        {
            "location": "/using-example-programs/#using-example-programs", 
            "text": "The example programs included with the Virtual Channel SDK are buildable, working virtual channels. Use these examples to:    Verify that your environment is suitable by building a known working example program.    Provide working examples of code that can be modified to suit your requirements.    Explore the features and functionality provided in the Virtual Channel SDK.    Each of these example programs comprises a client virtual driver and a server application. The server-side application is run from the command line within an ICA session. A single virtual channel comprises an application pair.  The example programs included with the Virtual Channel SDK are:  Ping : Records the round-trip delay time for a test packet sent over a virtual channel.  Mix : Demonstrates a mechanism to call functions (for example, to get the time of day) on a remote client.  Over : Simple asynchronous application that demonstrates how to code an application where the server must receive a response from the client asynchronously, and where the type of packet being sent to the client is different from the type received.", 
            "title": "Using Example Programs"
        }, 
        {
            "location": "/using-example-programs/#ping", 
            "text": "Ping is a simple program that records the round-trip delay time for a test packet sent over a virtual channel. The server sends a packet to the client and the client responds with a packet containing the time it received the original packet from the server. This sequence is repeated a specified number of times, and then the program displays the round-trip time for each ping and the average round-trip delay time.  For this example, there is no significant difference between a BEGIN packet and an END packet. The two types of packets are provided as an example for writing your own virtual channel protocols.  This program demonstrates:    How to write a manifest file so that Citrix Receiver for Android can detect and bind the service.    How to send information to a server-application (in this case, the number of times to send packets to the client).    How to transfer data synchronously. The sequence of events is:  {SrvWrite, ClntRead, ClntWrite, SrvRead} {SrvWrite, ClntRead} {...} . The server waits for the client to reply before sending the next packet.", 
            "title": "Ping"
        }, 
        {
            "location": "/using-example-programs/#packet-format", 
            "text": "The following packet is exchanged between the client and the server.  Byte 0-1 uSign; // Signature\nByte 2-3 uType; // Type, BEGIN or END, from server\nByte 4-5 uLen; // Packet length from server\nByte 6-7 uCounter; // Sequencer\nByte 8-11 ulServerMS; // Server millisecond clock\nByte 12-15 ulClientMS; // Client millisecond clock", 
            "title": "Packet Format"
        }, 
        {
            "location": "/using-example-programs/#mix", 
            "text": "Mix demonstrates a mechanism that you can use to call functions on a\nremote client (for example to get the time of day). This program\ndemonstrates an extensible scheme for making function calls from the\nserver to the client that allows the server to specify when it expects a\nresponse from the client and when it does not. This method can increase\nperformance, because the server does not have to constantly wait for a\nreply from the client.  The server calls a series of simple functions:    AddNo : Add two numbers and return the sum as the return value.    DispStr : Write a string to the log file. There is no return value (write-only function).    Gettime : Read the client time and return it as the return value.    The actual implementation of these functions is on the client side. The server conditionally waits for the response from the client, depending on the function being executed. For example, the server waits for the result of the  AddNo  or  Gettime  function, but not the write-only function  DispStr , which returns no result.", 
            "title": "Mix"
        }, 
        {
            "location": "/using-example-programs/#packet-format_1", 
            "text": "Byte 0-1 uType // Packet type\nByte 2-3 uFunc; // Index of Function\nByte 4-7 uLen; // Length of data\nByte 8-9 fRetReq; // True if return value required\nByte 10-13 dwRetVal; // Return Value from client\nByte 14-15 dwLen1; // length of data for \\#1 LpVoid\nByte 16-17 dwLen2; // length of data for \\#2 LpVoid  The data consists of the structure above followed by the arguments to the function being called. uLen is the total length of the data being sent, including the arguments. DwLen1 is the length of the data pointed to by a pointer argument.", 
            "title": "Packet Format"
        }, 
        {
            "location": "/using-example-programs/#sequence-of-events", 
            "text": "The Mix program demonstrates the following sequence of events. See the graphic below.  This figure illustrates the sequence of events that occur when you use the Mix program, starting at the top.", 
            "title": "Sequence of Events"
        }, 
        {
            "location": "/using-example-programs/#over", 
            "text": "Over is a simple asynchronous application. It demonstrates how to code an application in which the server must receive a response from the client asynchronously, and the type of packet being sent to the client is different from the type received.  When the Over program begins, it:    Spawns a thread that waits for a response from the client.    Begins sending data packets with sequence numbers to the client.    (After sending the last packet of data) sends a packet with a sequence number of  NO\\_MORE\\_DATA , and then closes the connection.    The client receives packets and inspects the sequence number. For every sequence number divisible by 10, the client increases the sequence number by 7 and sends a response to the server. These numbers are chosen arbitrarily to demonstrate that the client can asynchronously send data to the server at any time.  The packet type used to send data from the server to the client is different from the packet type used to receive data from the client.", 
            "title": "Over"
        }, 
        {
            "location": "/using-example-programs/#packet-format-from-server-to-client", 
            "text": "Byte 0-1 uSign; // Signature\nByte 2-3 uType; // Type, BEGIN or END, from server\nByte 4-5 uLen; // Packet length from server\nByte 6-7 uCounter; // Sequencer\nByte 8-11 ulServerMS; // Server millisecond clock", 
            "title": "Packet Format - From Server to Client"
        }, 
        {
            "location": "/using-example-programs/#packet-format-from-client-to-server", 
            "text": "Byte 0-1 uType; // Type OVERFLOW\\_JUMP from client\nByte 2-3 uLen; // Packet length from client\nByte 4-5 uCounter; // seqUencer", 
            "title": "Packet Format - From Client to Server"
        }, 
        {
            "location": "/using-example-programs/#sequence-of-events_1", 
            "text": "This figure illustrates the sequence of events that occur when you use the Over program, starting at the top.  ![](./over-sequence-of-events.png =625x)", 
            "title": "Sequence of Events"
        }, 
        {
            "location": "/using-example-programs/#building-examples", 
            "text": "", 
            "title": "Building Examples"
        }, 
        {
            "location": "/using-example-programs/#building-a-server-side-example-using-nmake", 
            "text": "Examples of the latest server-side executables have been provided for testing. You can download the latest Windows Virtual Channel SDK in order to develop the server-side component.", 
            "title": "Building a server-side example using Nmake"
        }, 
        {
            "location": "/using-example-programs/#building-a-client-side-example", 
            "text": "Citrix provides APKs for the three sample virtual drivers. You can build the APKs yourself. The packages for sample virtual drivers are built using Gradle.  Environment information of sample code:    Gradle version: 2.10.    Gradle build tool version: 21.1.2.    Android SDK version: 21.    JDK version: Oracle JDK 7.    Building steps:    Sets  \\$JAVA\\_HOME, \\$ANDROID\\_HOME, \\$GRADLE\\_HOME  to the directory you installed. Adds  \\$JAVA\\_HOME and \\$GRADLE\\_HOME/bin  to  \\$PATH .    Opens a Command line in the root directory of a sample package.    Runs \u201cgradle assemble\u201d in Commandline.    When a build completes, you can find the APKs under  ./app/build/outputs/apk .    The APKs must be installed to your device before an ICA session launches.", 
            "title": "Building a client-side example"
        }, 
        {
            "location": "/using-example-programs/#running-an-example-virtual-channel", 
            "text": "Examples of the latest server-side executables have been provided for testing.    On a client installed with the client-side example, connect to a server running XenApp or XenDesktop with the associated server-side example.    Within the ICA session, run the server-side executable.    The server-side example queries the client-side virtual driver, and then displays the driver information. Use the  -d  parameter to display detailed information. For Ping only:  CTXPING  sends  PingCount  separate pings.  PingCount  has a default value of three, but can be set in the  \\[Ping\\]  section of the  Module.ini  file. Each ping consists of a  BEGIN  packet and an  END  packet.", 
            "title": "Running an Example Virtual Channel"
        }, 
        {
            "location": "/programming-guide/", 
            "text": "Programming Guide\n\n\nThis version of Virtual Channel SDK illustrates how to implement the client virtual driver for the Android client. You can find resources on the Citrix website or by contacting us.\n\n\nThe client virtual driver for the Android client must be implemented as an Android service. The APIs in IVCService.aidl are to be implemented by the virtual driver.\n\n\nThis SDK provides a helper class to make the implementation more convenient.\n\n\nDesign Suggestions\n\n\nFollow these suggestions to make your virtual channels easier to design\nand enhance:\n\n\n\n\n\n\nWhen you design your own virtual channel protocol, allow for the flexibility to add features. Virtual channels have version numbers that are exchanged during initialization so that both the client and the server detect the maximum level of functionality that can be used. For example, if the client is at Version 3 and the server is at Version 5, the server does not send any packets with functionality beyond Version 3 because the client does not know how to interpret the newer packets.\n\n\n\n\n\n\nBecause you can implement the server side of a virtual channel protocol as a separate process, it is easier to write code that interfaces with the Citrix-provided virtual channel support on the server than on the client (where the code must fit into an existing code structure). The server side of a virtual channel simply opensthe channel, reads from and writes to it, and closes it when done.\n\n\n\n\n\n\nWriting code for the server-side is similar to writing an application that uses services exported by the system. It is easier to write an application to handle the virtual channel communication because it can then be run once for each ICA connection supporting the virtual channel.\n\n\n\n\n\n\nIf you are designing new hardware for use with new virtual channels (for example, an improved compressed video format), make sure the hardware can be detected so that the client can determine whether or not it is installed. Then the client can communicate to the server if the hardware is available before the server uses the new data format. Optionally, you could have the virtual driver translate the new data format for use with older hardware.\n\n\n\n\n\n\nThere might be limitations preventing your new virtual channel from performing at an optimum level. If the client is might not be sufficient bandwidth to properly support audio or video data. You can make your protocol adaptive, so that as\n    bandwidth decreases, performance degrades gracefully, possibly by\n    sending sound normally but reducing the frame rate of the video to\n    fit the available bandwidth.\n\n\n\n\n\n\nTo identify where problems are occurring (connection,\n    implementation, or protocol), first get the connection and\n    communication working. Then, after the virtual channel is complete\n    and debugged, do some time trials and record the results. These\n    results establish a baseline for measuring further optimizations\n    such as compression and other enhancements so that the channel\n    requires less bandwidth.\n\n\n\n\n\n\nCitrix Receiver for Android binds the virtual driver service using\n    the Android API bindService with flag \nBIND\\_AUTO\\_CREATE\n set. That\n    means that if the service has not been started before the ICA\n    session launches, Citrix Receiver for Android starts this\n    service automatically. So the virtual driver you write must never\n    block or perform time-consuming task in the \nonCreate()\n and \nonBind()\n\n    methods. Citrix Receiver for Android waits only two seconds\n    for binding.\n\n\n\n\n\n\nNaming Virtual Channels\n\n\nVirtual channels are referred to by a seven-character (or shorter) ASCII\nname. In several previous versions of the ICA protocol, virtual channels\nwere numbered. The numbers are now assigned dynamically based on the\nASCII name, making implementation easier.\n\n\nWhen developing virtual channel code for internal use only, you can use\nany seven-character name that does not conflict with existing virtual\nchannels. Use only upper and lowercase ASCII letters and numbers. Follow\nthe existing naming convention when adding your own virtual channels.\n\n\nThe predefined channels, which begin with the OEM identifier CTX, are\nfor use only by Citrix.\n\n\nDeclare Intent Filter in Manifest File\n\n\nIn the manifest file of your package, you must declare the following\nintent action in the section for virtual driver service (Refer to the\nsample code) so that Citrix Receiver for Android can detect and bind\nyour virtual driver service.\n\n\nintent-filter\n\n\n    \naction android:name=\ncom.citrix.action.vcsdk.BIND\n\n\n\n/intent-filter\n\n\n\n\n\n\nAIDL Interfaces Overview\n\n\nWhen the virtual driver and Citrix Receiver\nfor Android bind successfully, they communicate with each other through\nthe AIDL interfaces.\n\n\nIn this version of the Virtual Channel SDK, Citrix provides two AIDL\ninterfaces: \nIVCService.aidl\n and \nIVCCallback.aidl\n. You must implement the\nAPIs in \nIVCService.aidl\n. The APIs in \nIVCCallback.aidl\n have been\nimplemented by Citrix for your usage.\n\n\nYou must include the two AIDL interfaces in your custom virtual driver\npackage. And the contents of the two interfaces must not be modified.\n\n\nUser-implemented Methods\n\n\nAll user-defined methods are in IVCService.aidl. You must implement:\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncanLoad\n\n\nChecks whether the driver is ready to load. It is the first remote call in Citrix Receiver for Android.\n\n\n\n\n\n\ngetDisplayName\n\n\nReturns the display name of the virtual channel. It is sent to the server and used to report errors from the virtual channel.\n\n\n\n\n\n\ngetMinVersionNumber\n\n\nReturns \nminVersion\n, the lowest supported version of this virtual channel. It is used to allow version negotiation between the client-side and the server-side components.\n\n\n\n\n\n\ngetMaxVersionNumber\n\n\nReturns \nmaxVersion\n, the highest supported version of this virtual channel. It is used to allow version negotiation between the client-side and the server-side components.\n\n\n\n\n\n\ngetVCName\n\n\nReturns \nstreamName\n used to identify the virtual channel to the server. For more information, see Naming Virtual Channels. Note that strings starting with, \"CTX\" are reserved for use only by Citrix.\n\n\n\n\n\n\ninitializeDriver\n\n\nThis method is for the service to do initialization work before the virtual channel starts. Returning Boolean values shows the status of initialization.\n\n\n\n\n\n\ngetDriverInfo\n\n\nWhen an ICA session starts, Citrix Receiver for Android calls this method to retrieve module-specific information for transmission to the host. Information is returned to the server side of the virtual channel by \nWFVirtualChannelQuery()\n.\n\n\n\n\n\n\ndriverStart\n\n\nCalled when Citrix Receiver for Android starts the virtual driver. The instance of \nIVCCallback\n is provided to virtual driver by this API.\n\n\n\n\n\n\nicaDataArrival\n\n\nThis method is called repeatedly when the virtual driver is running. The implementation must read command bytes from its vStream byte array and process them accordingly.\n\n\n\n\n\n\ndriverShutdown\n\n\nCalled when the virtual channel is shut down. Once the virtual channel closes, data cannot be sent to the server. This method can free all resources held by the virtual channel.\n\n\n\n\n\n\n### Callback Methods\n\n\n\n\n\n\n\n\n\n\nThe virtual driver uses the callback method to send data to the server and confirm a driver shutdown event. When driverStart starts the virtual driver, an instance of \nIVCCallback\n is passed to the virtual driver.\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsendData\n\n\nSends a package of virtual channel data to the server.\n\n\n\n\n\n\nconfirmShutdown\n\n\nTo make sure that all data sent from the Client is done, and it is safe to terminate the channel. Called to confirm that the virtual channel can be shutdown. It must be called after \ndriverShutdown\n is called. When \ndriverShutdown\n is called, Citrix Receiver for Android waits for confirmation. The virtual driver can call \nconfirmShutdown\n to confirm that the virtual channel can be closed. And if this method is not called in time, the virtual channel will still be closed. Once the virtual channel closes, the data sent to the server will be ignored.\n\n\n\n\n\n\n\n\nHelper Class\n\n\nMarshall.java\n\n\nTo make the implementation of the virtual driver more convenient, Citrix provides a help class \nMarshall.java\n in this version of SDK. Data coming from the server and sending to the server are all encapsulated as byte array. \nMarshall.java\n provides some helper methods to read data from byte array and write data to byte array or \nByteArraryOutputStream\n. Citrix encourages you to include this class in your package and use the methods in \nMarshall.java\n to avoid making mistakes. For usage of these methods, refer to the three samples.", 
            "title": "Programming Guide"
        }, 
        {
            "location": "/programming-guide/#programming-guide", 
            "text": "This version of Virtual Channel SDK illustrates how to implement the client virtual driver for the Android client. You can find resources on the Citrix website or by contacting us.  The client virtual driver for the Android client must be implemented as an Android service. The APIs in IVCService.aidl are to be implemented by the virtual driver.  This SDK provides a helper class to make the implementation more convenient.", 
            "title": "Programming Guide"
        }, 
        {
            "location": "/programming-guide/#design-suggestions", 
            "text": "Follow these suggestions to make your virtual channels easier to design\nand enhance:    When you design your own virtual channel protocol, allow for the flexibility to add features. Virtual channels have version numbers that are exchanged during initialization so that both the client and the server detect the maximum level of functionality that can be used. For example, if the client is at Version 3 and the server is at Version 5, the server does not send any packets with functionality beyond Version 3 because the client does not know how to interpret the newer packets.    Because you can implement the server side of a virtual channel protocol as a separate process, it is easier to write code that interfaces with the Citrix-provided virtual channel support on the server than on the client (where the code must fit into an existing code structure). The server side of a virtual channel simply opensthe channel, reads from and writes to it, and closes it when done.    Writing code for the server-side is similar to writing an application that uses services exported by the system. It is easier to write an application to handle the virtual channel communication because it can then be run once for each ICA connection supporting the virtual channel.    If you are designing new hardware for use with new virtual channels (for example, an improved compressed video format), make sure the hardware can be detected so that the client can determine whether or not it is installed. Then the client can communicate to the server if the hardware is available before the server uses the new data format. Optionally, you could have the virtual driver translate the new data format for use with older hardware.    There might be limitations preventing your new virtual channel from performing at an optimum level. If the client is might not be sufficient bandwidth to properly support audio or video data. You can make your protocol adaptive, so that as\n    bandwidth decreases, performance degrades gracefully, possibly by\n    sending sound normally but reducing the frame rate of the video to\n    fit the available bandwidth.    To identify where problems are occurring (connection,\n    implementation, or protocol), first get the connection and\n    communication working. Then, after the virtual channel is complete\n    and debugged, do some time trials and record the results. These\n    results establish a baseline for measuring further optimizations\n    such as compression and other enhancements so that the channel\n    requires less bandwidth.    Citrix Receiver for Android binds the virtual driver service using\n    the Android API bindService with flag  BIND\\_AUTO\\_CREATE  set. That\n    means that if the service has not been started before the ICA\n    session launches, Citrix Receiver for Android starts this\n    service automatically. So the virtual driver you write must never\n    block or perform time-consuming task in the  onCreate()  and  onBind() \n    methods. Citrix Receiver for Android waits only two seconds\n    for binding.", 
            "title": "Design Suggestions"
        }, 
        {
            "location": "/programming-guide/#naming-virtual-channels", 
            "text": "Virtual channels are referred to by a seven-character (or shorter) ASCII\nname. In several previous versions of the ICA protocol, virtual channels\nwere numbered. The numbers are now assigned dynamically based on the\nASCII name, making implementation easier.  When developing virtual channel code for internal use only, you can use\nany seven-character name that does not conflict with existing virtual\nchannels. Use only upper and lowercase ASCII letters and numbers. Follow\nthe existing naming convention when adding your own virtual channels.  The predefined channels, which begin with the OEM identifier CTX, are\nfor use only by Citrix.", 
            "title": "Naming Virtual Channels"
        }, 
        {
            "location": "/programming-guide/#declare-intent-filter-in-manifest-file", 
            "text": "In the manifest file of your package, you must declare the following\nintent action in the section for virtual driver service (Refer to the\nsample code) so that Citrix Receiver for Android can detect and bind\nyour virtual driver service.  intent-filter \n\n     action android:name= com.citrix.action.vcsdk.BIND  /intent-filter", 
            "title": "Declare Intent Filter in Manifest File"
        }, 
        {
            "location": "/programming-guide/#aidl-interfaces-overview", 
            "text": "When the virtual driver and Citrix Receiver\nfor Android bind successfully, they communicate with each other through\nthe AIDL interfaces.  In this version of the Virtual Channel SDK, Citrix provides two AIDL\ninterfaces:  IVCService.aidl  and  IVCCallback.aidl . You must implement the\nAPIs in  IVCService.aidl . The APIs in  IVCCallback.aidl  have been\nimplemented by Citrix for your usage.  You must include the two AIDL interfaces in your custom virtual driver\npackage. And the contents of the two interfaces must not be modified.", 
            "title": "AIDL Interfaces Overview"
        }, 
        {
            "location": "/programming-guide/#user-implemented-methods", 
            "text": "All user-defined methods are in IVCService.aidl. You must implement:     Method  Description      canLoad  Checks whether the driver is ready to load. It is the first remote call in Citrix Receiver for Android.    getDisplayName  Returns the display name of the virtual channel. It is sent to the server and used to report errors from the virtual channel.    getMinVersionNumber  Returns  minVersion , the lowest supported version of this virtual channel. It is used to allow version negotiation between the client-side and the server-side components.    getMaxVersionNumber  Returns  maxVersion , the highest supported version of this virtual channel. It is used to allow version negotiation between the client-side and the server-side components.    getVCName  Returns  streamName  used to identify the virtual channel to the server. For more information, see Naming Virtual Channels. Note that strings starting with, \"CTX\" are reserved for use only by Citrix.    initializeDriver  This method is for the service to do initialization work before the virtual channel starts. Returning Boolean values shows the status of initialization.    getDriverInfo  When an ICA session starts, Citrix Receiver for Android calls this method to retrieve module-specific information for transmission to the host. Information is returned to the server side of the virtual channel by  WFVirtualChannelQuery() .    driverStart  Called when Citrix Receiver for Android starts the virtual driver. The instance of  IVCCallback  is provided to virtual driver by this API.    icaDataArrival  This method is called repeatedly when the virtual driver is running. The implementation must read command bytes from its vStream byte array and process them accordingly.    driverShutdown  Called when the virtual channel is shut down. Once the virtual channel closes, data cannot be sent to the server. This method can free all resources held by the virtual channel.    ### Callback Methods      The virtual driver uses the callback method to send data to the server and confirm a driver shutdown event. When driverStart starts the virtual driver, an instance of  IVCCallback  is passed to the virtual driver.     Function  Description      sendData  Sends a package of virtual channel data to the server.    confirmShutdown  To make sure that all data sent from the Client is done, and it is safe to terminate the channel. Called to confirm that the virtual channel can be shutdown. It must be called after  driverShutdown  is called. When  driverShutdown  is called, Citrix Receiver for Android waits for confirmation. The virtual driver can call  confirmShutdown  to confirm that the virtual channel can be closed. And if this method is not called in time, the virtual channel will still be closed. Once the virtual channel closes, the data sent to the server will be ignored.", 
            "title": "User-implemented Methods"
        }, 
        {
            "location": "/programming-guide/#helper-class", 
            "text": "", 
            "title": "Helper Class"
        }, 
        {
            "location": "/programming-guide/#marshalljava", 
            "text": "To make the implementation of the virtual driver more convenient, Citrix provides a help class  Marshall.java  in this version of SDK. Data coming from the server and sending to the server are all encapsulated as byte array.  Marshall.java  provides some helper methods to read data from byte array and write data to byte array or  ByteArraryOutputStream . Citrix encourages you to include this class in your package and use the methods in  Marshall.java  to avoid making mistakes. For usage of these methods, refer to the three samples.", 
            "title": "Marshall.java"
        }, 
        {
            "location": "/known-limitations/", 
            "text": "Known Limitations\n\n\nThere are two known limitations for some Android devices of specific manufacturers.\n\n\n\n\n\n\nFor some Huawei devices, secondary launch is disabled by default. To\n    use this version of the Virtual Channel SDK, you must change the\n    setting on your device. \n\n\nFor example, for Huawei P9, follow the steps below:\n\n\nIn Phone Manager, choose \nApp auto-launch\n, then choose \nSecondary launch\nmanagement\n, and enable the virtual driver services. \n\n\n\n\n\n\n\nFor some Samsung devices with Android 6.0.1, if the App containing\n    the custom virtual driver service is not in foreground for long\n    time, the virtual driver service cannot be started by Citrix\n    Receiver for Android. The requirement for using Samsung devices with\n    Android 6.0.1 is that you must launch virtual driver App manually\n    every time before you launch an ICA session. Note that the\n    requirement here is not to start the virtual driver\n    service manually. It is to start the App that contains the service\n    by clicking the icon of this App.", 
            "title": "Known Limitations"
        }, 
        {
            "location": "/known-limitations/#known-limitations", 
            "text": "There are two known limitations for some Android devices of specific manufacturers.    For some Huawei devices, secondary launch is disabled by default. To\n    use this version of the Virtual Channel SDK, you must change the\n    setting on your device.   For example, for Huawei P9, follow the steps below:  In Phone Manager, choose  App auto-launch , then choose  Secondary launch\nmanagement , and enable the virtual driver services.     For some Samsung devices with Android 6.0.1, if the App containing\n    the custom virtual driver service is not in foreground for long\n    time, the virtual driver service cannot be started by Citrix\n    Receiver for Android. The requirement for using Samsung devices with\n    Android 6.0.1 is that you must launch virtual driver App manually\n    every time before you launch an ICA session. Note that the\n    requirement here is not to start the virtual driver\n    service manually. It is to start the App that contains the service\n    by clicking the icon of this App.", 
            "title": "Known Limitations"
        }, 
        {
            "location": "/programming-reference/", 
            "text": "Programming Reference\n\n\nFor function summaries, see:\n\n\n\n\nAIDL Interfaces Overview\n\n\n\n\ncanLoad\n\n\nDetermines whether this driver can be loaded without error. It is the\nfirst remote call in the Reicever.\n\n\nCalling Convention\n\n\nboolean canLoad();\n\n\n\n\n\nParameters\n\n\nNone\n\n\nReturn Values\n\n\nIf virtual driver is ready to work, the returned value is true. If not, returns \nfalse\n.\n\n\nRemarks\n\n\nWhen this method returns the value false, the virtual channel for this\nvirtual driver cannot be created. That means the virtual driver cannot\nwork in the ICA session.\n\n\ngetDisplayName\n\n\nReturns display name of virtual channel and it is sent to the server.\n\n\nCalling Convention\n\n\nString getDisplayName();\n\n\n\n\n\nParameters\n\n\nNone\n\n\nReturn Values\n\n\nReturns display name of virtual channel as String.\n\n\nRemarks\n\n\nDisplay name is a friendly name of virtual channel, used to report\nerrors.\n\n\ngetMinVersionNumber\n\n\nReturns \nminVersion\n, the lowest supported version of this virtual channel, used to allow version\nnegotiation between the client-side and the server-side components.\n\n\nCalling Convention\n\n\nint getMinVersionNumber();\n\n\n\n\n\nParameters\n\n\nNone\n\n\nReturn Value\n\n\nThe lowest supported version of this virtual channel.\n\n\nRemarks\n\n\nRegarding the usage of virtual channel version, refers to Design Suggesstions.\n\n\ngetMaxVersionNumber\n\n\nReturns \nmaxVersion\n the highest supported version of this virtual channel, used to allow version\nnegotiation between the client-side and the server-side components.\n\n\nCalling Convention\n\n\nint getMaxVersionNumber();\n\n\n\n\n\nParameters\n\n\nNone\n\n\nReturn Value\n\n\nThe highest supported version of this virtual channel.\n\n\nRemarks\n\n\nRegarding the usage of virtual channel version, refers to Design Suggesstions.\n\n\ngetVCName\n\n\nReturns the virtual channel name, send to identify\nthe virtual channel to the server.\n\n\nCalling Convention\n\n\nString getVCName();\n\n\n\n\n\nParameters\n\n\nNone\n\n\nReturn Values\n\n\nReturns the virtual channel name.\n\n\nRemarks\n\n\nEach virtual channel has a unique name to identify itself. For more information, see Naming Virtual Channels.\n\n\ninitializeDriver\n\n\nThis method is for service to do initialization work before the virtual channel starts.\n\n\nCalling Convention\n\n\nboolean initializeDriver ();\n\n\n\n\n\nParameters\n\n\nNone\n\n\nReturn Values\n\n\nReturns boolean value showing the status of initialization. If initialization is successful, this method returns the value true. If unsuccessful, this method returns the value false.\n\n\nRemarks\n\n\nIf this method returns false, a virtual channel for this method cannot be created.\n\n\ngetDriverInfo\n\n\nWhen an ICA session starts, it calls this method to retrieve module-specific information for transmission to the server. This information returns to the server side of the virtual channel by \nWFVirtualChannelQuery()\n.\n\n\nCalling Convention\n\n\nbyte[] getDriverInfo();\n\n\n\n\n\nParameters\n\n\nNone\n\n\nReturn Value\n\n\nReturns \nbyte[]\n, the output byte array to be sent to the server.\n\n\nRemarks\n\n\ndriverStart\n\n\nCalled when the virtual driver is started by Citrix Receiver for Android.\n\n\nCalling Convention\n\n\nvoid driverStart(in IVCCallback cb);\n\n\n\n\n\nParameters\n\n\ncb\n\n\nThe callback provided to the virtual driver service.\n\n\nReturn Value\n\n\nNone\n\n\nRemarks\n\n\nThe instance of \nIVCCallback\n is passed to the virtual driver in this method. Citrix recommends that you must not call \nsendData\n in \ndriverStart\n. The callbacks must be used after \ndriverStart\n returns.\n\n\nicaDataArrival\n\n\nThis method is called repeatedly when the virtual driver is running. The\nimplementation must read command bytes from its vStream byte array and\nprocess them accordingly.\n\n\nCalling Convention\n\n\nvoid icaDataArrival(in byte[] vStream);\n\n\n\n\n\nParameters\n\n\nvStream\n\n\nThe byte array used to read data from the server component of the virtual channel.\n\n\nReturn Value\n\n\nNone\n\n\nRemarks\n\n\nBecause Citrix Receiver for Android does not know any package detail, it only transfers all available data from ICA stream to the virtual driver by calling this method. If the virtual channel package is too large, the whole package may not arrive at the same time. That means the implementation of this method must have the ability to handle partial package. See Ping, Over\nand Mix sample codes, which provide examples about how to handle partial package.\n\n\nIf the server-application sends several packages continuously, more than one package may come in the same byte array. Thus, the implementation of this method must have the ability to handle more than one package in the array. See Over and Mix sample codes, which provide the example about how to handle more than one packages in one byte array. For Ping sample, server application sends data synchronously. The server waits for the client to reply before sending the next packet, so Ping sample doesn\u2019t need to handle this scenario.\n\n\ndriverShutdown\n\n\nCalled when virtual channel is shut down by Citrix Receiver for Android.\n\n\nCalling Convention\n\n\nvoid driverShutdown();\n\n\n\n\n\nParameters\n\n\nNone\n\n\nReturn Value\n\n\nNone\n\n\nRemarks\n\n\nThis method is to inform the virtual driver that the virtual channel\ncloses. Once virtual channel closes, data cannot be sent to server. And\nCitrix Receiver for Android waits for confirmation after calling this\nmethod. If virtual driver doesn\u2019t call \nconfirmShutdown()\n to confirm in\ntime, virtual channel keeps close.\n\n\nsendData\n\n\nTo send a package of channel protocol to the server.\n\n\nCalling Convention\n\n\nvoid sendData(in byte[] data, in int off, in int length);\n\n\n\n\n\nParameters\n\n\ndata\n\n\nThe data as byte array is to be sent to the server side.\n\n\noff\n\n\nThe start offset in the data array.\n\n\nlength\n\n\nLength the number of bytes to send.\n\n\nReturn Value\n\n\nNone.\n\n\nRemarks\n\n\nThis method must be used after driverStart returns and before \ndriverShutdown\n is called.\n\n\nconfirmShutdown\n\n\nCalled to confirm that the virtual channel can be shut down. It must be\ncalled after \ndriverShutdown()\n is called. Once confirmed, data sent to\nthe server component are ignored.\n\n\nCalling Convention\n\n\nvoid confirmShutdown();\n\n\n\n\n\nParameters\n\n\nNone\n\n\nReturn Value\n\n\nNone\n\n\nRemarks\n\n\nTo make sure that all data sent from the Client is done, and it is safe\nto terminate the channel. This method must be called after\ndriverShutdown is called. When \ndriverShutdown\n is called, Citrix Receiver\nfor Android waits for confirmation. Virtual driver can call\nconfirmShutdown to confirm that the virtual channel can be closed. And\nif this method is not called in time, the virtual channel is still\nclosed.\n\n\nwriteInt2\n\n\nWrites an int to a buffer in the form of two bytes, little endian order.\n\n\nCalling Convention\n\n\nint writeInt2(byte[] buffer, int offset, int i)\n\n\n\n\n\nParameters\n\n\nbuffer\n\n\nThe buffer to write the integer to.\n\n\noffset\n\n\nOffset from the start of buffer, where this method starts writing the\nint.\n\n\ni\n\n\nThe int to write.\n\n\nReturn Value\n\n\nReturns offset + 2.\n\n\nRemarks\n\n\nwriteInt4\n\n\nWrites an int to a buffer in the form of four bytes, little endian\norder.\n\n\nCalling Convention\n\n\nint writeInt4(byte[] buffer, int offset, int i)\n\n\n\n\n\nParameters\n\n\nbuffer\n\n\nThe buffer to write the integer to.\n\n\noffset\n\n\nOffset from the start of buffer, where this method will start writing\nthe int.\n\n\ni\n\n\nThe int to write.\n\n\nReturn Value\n\n\nReturns offset + 4.\n\n\nRemarks\n\n\nwriteInt2\n\n\nWrites an int to an output stream in the form of two bytes, little\nendian order.\n\n\nCalling Convention\n\n\nvoid writeInt2(ByteArrayOutputStream stream, int i)\n\n\n\n\n\nParameters\n\n\nstream\n\n\nThe stream to write the integer to.\n\n\ni\n\n\nThe int to write.\n\n\nReturn Value\n\n\nRemarks\n\n\nwriteInt4\n\n\nWrites an int to an output stream in the form of four bytes, little endian order.\n\n\nCalling Convention\n\n\nvoid writeInt4(ByteArrayOutputStream stream, int i)\n\n\n\n\n\nParameters\n\n\nstream\n\n\nThe stream to write the integer to.\n\n\ni\n\n\nThe int to write.\n\n\nReturn Value\n\n\nRemarks\n\n\nreadInt2\n\n\nReads two bytes from a byte array in little endian order and creates a 2\nbyte short.\n\n\nCalling Convention\n\n\nshort readInt2(byte[] buffer, int index)\n\n\n\n\n\nParameters\n\n\nbuffer\n\n\nThe buffer to read the short integer from.\n\n\noffset\n\n\nOffset from the start of buffer, where this method starts reading the\nshort integer.\n\n\nReturn Value\n\n\nReturns the short integer.\n\n\nRemarks\n\n\nreadInt4\n\n\nReads four bytes from a byte array in little endian order and creates a\n4 byte integer.\n\n\nCalling Convention\n\n\nint readInt4(byte[] buffer, int index)\n\n\n\n\n\nParameters\n\n\nbuffer\n\n\nThe buffer to read the integer from.\n\n\noffset\n\n\nOffset from the start of buffer, where this method starts reading the\ninteger.\n\n\nReturn Value\n\n\nReturns the integer.\n\n\nRemarks\n\n\nreadUInt2\n\n\nReads two bytes from a byte array in little endian order and creates an\nunsigned value stored in an integer.\n\n\nCalling Convention\n\n\nint readUInt2(byte[] buffer, int index)\n\n\n\n\n\nParameters\n\n\nbuffer\n\n\nThe buffer to read the unsigned integer from.\n\n\noffset\n\n\nOffset from the start of buffer, where this method starts reading the\nunsigned integer.\n\n\nReturn Value\n\n\nReturns the unsigned integer.\n\n\nRemarks\n\n\nreadUInt1\n\n\nReads one byte from a byte array in little endian order and creates an\nunsigned value stored in an integer.\n\n\nCalling Convention\n\n\nint readUInt1(byte[] buffer, int index)\n\n\n\n\n\nParameters\n\n\nbuffer\n\n\nThe buffer to read the unsigned integer from.\n\n\noffset\n\n\nOffset from the start of buffer, where this method starts reading the\nunsigned integer.\n\n\nReturn Value\n\n\nReturns the unsigned integer.", 
            "title": "Programming Reference"
        }, 
        {
            "location": "/programming-reference/#programming-reference", 
            "text": "For function summaries, see:   AIDL Interfaces Overview", 
            "title": "Programming Reference"
        }, 
        {
            "location": "/programming-reference/#canload", 
            "text": "Determines whether this driver can be loaded without error. It is the\nfirst remote call in the Reicever.", 
            "title": "canLoad"
        }, 
        {
            "location": "/programming-reference/#calling-convention", 
            "text": "boolean canLoad();", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-values", 
            "text": "If virtual driver is ready to work, the returned value is true. If not, returns  false .", 
            "title": "Return Values"
        }, 
        {
            "location": "/programming-reference/#remarks", 
            "text": "When this method returns the value false, the virtual channel for this\nvirtual driver cannot be created. That means the virtual driver cannot\nwork in the ICA session.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#getdisplayname", 
            "text": "Returns display name of virtual channel and it is sent to the server.", 
            "title": "getDisplayName"
        }, 
        {
            "location": "/programming-reference/#calling-convention_1", 
            "text": "String getDisplayName();", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-values_1", 
            "text": "Returns display name of virtual channel as String.", 
            "title": "Return Values"
        }, 
        {
            "location": "/programming-reference/#remarks_1", 
            "text": "Display name is a friendly name of virtual channel, used to report\nerrors.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#getminversionnumber", 
            "text": "Returns  minVersion , the lowest supported version of this virtual channel, used to allow version\nnegotiation between the client-side and the server-side components.", 
            "title": "getMinVersionNumber"
        }, 
        {
            "location": "/programming-reference/#calling-convention_2", 
            "text": "int getMinVersionNumber();", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_2", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value", 
            "text": "The lowest supported version of this virtual channel.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_2", 
            "text": "Regarding the usage of virtual channel version, refers to Design Suggesstions.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#getmaxversionnumber", 
            "text": "Returns  maxVersion  the highest supported version of this virtual channel, used to allow version\nnegotiation between the client-side and the server-side components.", 
            "title": "getMaxVersionNumber"
        }, 
        {
            "location": "/programming-reference/#calling-convention_3", 
            "text": "int getMaxVersionNumber();", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_3", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_1", 
            "text": "The highest supported version of this virtual channel.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_3", 
            "text": "Regarding the usage of virtual channel version, refers to Design Suggesstions.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#getvcname", 
            "text": "Returns the virtual channel name, send to identify\nthe virtual channel to the server.", 
            "title": "getVCName"
        }, 
        {
            "location": "/programming-reference/#calling-convention_4", 
            "text": "String getVCName();", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_4", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-values_2", 
            "text": "Returns the virtual channel name.", 
            "title": "Return Values"
        }, 
        {
            "location": "/programming-reference/#remarks_4", 
            "text": "Each virtual channel has a unique name to identify itself. For more information, see Naming Virtual Channels.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#initializedriver", 
            "text": "This method is for service to do initialization work before the virtual channel starts.", 
            "title": "initializeDriver"
        }, 
        {
            "location": "/programming-reference/#calling-convention_5", 
            "text": "boolean initializeDriver ();", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_5", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-values_3", 
            "text": "Returns boolean value showing the status of initialization. If initialization is successful, this method returns the value true. If unsuccessful, this method returns the value false.", 
            "title": "Return Values"
        }, 
        {
            "location": "/programming-reference/#remarks_5", 
            "text": "If this method returns false, a virtual channel for this method cannot be created.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#getdriverinfo", 
            "text": "When an ICA session starts, it calls this method to retrieve module-specific information for transmission to the server. This information returns to the server side of the virtual channel by  WFVirtualChannelQuery() .", 
            "title": "getDriverInfo"
        }, 
        {
            "location": "/programming-reference/#calling-convention_6", 
            "text": "byte[] getDriverInfo();", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_6", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_2", 
            "text": "Returns  byte[] , the output byte array to be sent to the server.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_6", 
            "text": "", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#driverstart", 
            "text": "Called when the virtual driver is started by Citrix Receiver for Android.", 
            "title": "driverStart"
        }, 
        {
            "location": "/programming-reference/#calling-convention_7", 
            "text": "void driverStart(in IVCCallback cb);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_7", 
            "text": "cb  The callback provided to the virtual driver service.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_3", 
            "text": "None", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_7", 
            "text": "The instance of  IVCCallback  is passed to the virtual driver in this method. Citrix recommends that you must not call  sendData  in  driverStart . The callbacks must be used after  driverStart  returns.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#icadataarrival", 
            "text": "This method is called repeatedly when the virtual driver is running. The\nimplementation must read command bytes from its vStream byte array and\nprocess them accordingly.", 
            "title": "icaDataArrival"
        }, 
        {
            "location": "/programming-reference/#calling-convention_8", 
            "text": "void icaDataArrival(in byte[] vStream);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_8", 
            "text": "vStream  The byte array used to read data from the server component of the virtual channel.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_4", 
            "text": "None", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_8", 
            "text": "Because Citrix Receiver for Android does not know any package detail, it only transfers all available data from ICA stream to the virtual driver by calling this method. If the virtual channel package is too large, the whole package may not arrive at the same time. That means the implementation of this method must have the ability to handle partial package. See Ping, Over\nand Mix sample codes, which provide examples about how to handle partial package.  If the server-application sends several packages continuously, more than one package may come in the same byte array. Thus, the implementation of this method must have the ability to handle more than one package in the array. See Over and Mix sample codes, which provide the example about how to handle more than one packages in one byte array. For Ping sample, server application sends data synchronously. The server waits for the client to reply before sending the next packet, so Ping sample doesn\u2019t need to handle this scenario.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#drivershutdown", 
            "text": "Called when virtual channel is shut down by Citrix Receiver for Android.", 
            "title": "driverShutdown"
        }, 
        {
            "location": "/programming-reference/#calling-convention_9", 
            "text": "void driverShutdown();", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_9", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_5", 
            "text": "None", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_9", 
            "text": "This method is to inform the virtual driver that the virtual channel\ncloses. Once virtual channel closes, data cannot be sent to server. And\nCitrix Receiver for Android waits for confirmation after calling this\nmethod. If virtual driver doesn\u2019t call  confirmShutdown()  to confirm in\ntime, virtual channel keeps close.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#senddata", 
            "text": "To send a package of channel protocol to the server.", 
            "title": "sendData"
        }, 
        {
            "location": "/programming-reference/#calling-convention_10", 
            "text": "void sendData(in byte[] data, in int off, in int length);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_10", 
            "text": "data  The data as byte array is to be sent to the server side.  off  The start offset in the data array.  length  Length the number of bytes to send.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_6", 
            "text": "None.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_10", 
            "text": "This method must be used after driverStart returns and before  driverShutdown  is called.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#confirmshutdown", 
            "text": "Called to confirm that the virtual channel can be shut down. It must be\ncalled after  driverShutdown()  is called. Once confirmed, data sent to\nthe server component are ignored.", 
            "title": "confirmShutdown"
        }, 
        {
            "location": "/programming-reference/#calling-convention_11", 
            "text": "void confirmShutdown();", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_11", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_7", 
            "text": "None", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_11", 
            "text": "To make sure that all data sent from the Client is done, and it is safe\nto terminate the channel. This method must be called after\ndriverShutdown is called. When  driverShutdown  is called, Citrix Receiver\nfor Android waits for confirmation. Virtual driver can call\nconfirmShutdown to confirm that the virtual channel can be closed. And\nif this method is not called in time, the virtual channel is still\nclosed.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#writeint2", 
            "text": "Writes an int to a buffer in the form of two bytes, little endian order.", 
            "title": "writeInt2"
        }, 
        {
            "location": "/programming-reference/#calling-convention_12", 
            "text": "int writeInt2(byte[] buffer, int offset, int i)", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_12", 
            "text": "buffer  The buffer to write the integer to.  offset  Offset from the start of buffer, where this method starts writing the\nint.  i  The int to write.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_8", 
            "text": "Returns offset + 2.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_12", 
            "text": "", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#writeint4", 
            "text": "Writes an int to a buffer in the form of four bytes, little endian\norder.", 
            "title": "writeInt4"
        }, 
        {
            "location": "/programming-reference/#calling-convention_13", 
            "text": "int writeInt4(byte[] buffer, int offset, int i)", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_13", 
            "text": "buffer  The buffer to write the integer to.  offset  Offset from the start of buffer, where this method will start writing\nthe int.  i  The int to write.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_9", 
            "text": "Returns offset + 4.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_13", 
            "text": "", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#writeint2_1", 
            "text": "Writes an int to an output stream in the form of two bytes, little\nendian order.", 
            "title": "writeInt2"
        }, 
        {
            "location": "/programming-reference/#calling-convention_14", 
            "text": "void writeInt2(ByteArrayOutputStream stream, int i)", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_14", 
            "text": "stream  The stream to write the integer to.  i  The int to write.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_10", 
            "text": "", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_14", 
            "text": "", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#writeint4_1", 
            "text": "Writes an int to an output stream in the form of four bytes, little endian order.", 
            "title": "writeInt4"
        }, 
        {
            "location": "/programming-reference/#calling-convention_15", 
            "text": "void writeInt4(ByteArrayOutputStream stream, int i)", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_15", 
            "text": "stream  The stream to write the integer to.  i  The int to write.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_11", 
            "text": "", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_15", 
            "text": "", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#readint2", 
            "text": "Reads two bytes from a byte array in little endian order and creates a 2\nbyte short.", 
            "title": "readInt2"
        }, 
        {
            "location": "/programming-reference/#calling-convention_16", 
            "text": "short readInt2(byte[] buffer, int index)", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_16", 
            "text": "buffer  The buffer to read the short integer from.  offset  Offset from the start of buffer, where this method starts reading the\nshort integer.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_12", 
            "text": "Returns the short integer.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_16", 
            "text": "", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#readint4", 
            "text": "Reads four bytes from a byte array in little endian order and creates a\n4 byte integer.", 
            "title": "readInt4"
        }, 
        {
            "location": "/programming-reference/#calling-convention_17", 
            "text": "int readInt4(byte[] buffer, int index)", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_17", 
            "text": "buffer  The buffer to read the integer from.  offset  Offset from the start of buffer, where this method starts reading the\ninteger.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_13", 
            "text": "Returns the integer.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_17", 
            "text": "", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#readuint2", 
            "text": "Reads two bytes from a byte array in little endian order and creates an\nunsigned value stored in an integer.", 
            "title": "readUInt2"
        }, 
        {
            "location": "/programming-reference/#calling-convention_18", 
            "text": "int readUInt2(byte[] buffer, int index)", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_18", 
            "text": "buffer  The buffer to read the unsigned integer from.  offset  Offset from the start of buffer, where this method starts reading the\nunsigned integer.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_14", 
            "text": "Returns the unsigned integer.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_18", 
            "text": "", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#readuint1", 
            "text": "Reads one byte from a byte array in little endian order and creates an\nunsigned value stored in an integer.", 
            "title": "readUInt1"
        }, 
        {
            "location": "/programming-reference/#calling-convention_19", 
            "text": "int readUInt1(byte[] buffer, int index)", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_19", 
            "text": "buffer  The buffer to read the unsigned integer from.  offset  Offset from the start of buffer, where this method starts reading the\nunsigned integer.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_15", 
            "text": "Returns the unsigned integer.", 
            "title": "Return Value"
        }
    ]
}